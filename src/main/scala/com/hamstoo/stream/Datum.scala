package com.hamstoo.stream

import com.hamstoo.utils.{ObjectId, TimeStamp}
import spire.tailrec

/**
  * Entity IDs are either an ObjectId/String paired with a type label, e.g. ReprId, or a collection of such
  * items, e.g. CompoundId.  A UnitId is another special kind of entity ID that doesn't correspond to any
  * particular entity, but which is joinable to all of them--e.g. think an average value computed cross-sectionally
  * for all entities in the universe at a particular point in time.
  */
trait EntityId
case class UnitId() extends EntityId
case class ReprId(id: ObjectId) extends EntityId
case class CompoundId(ids: Set[EntityId]) extends EntityId

object EntityId {

  /** If two (compound) entity IDs match on all of the dimensions that they both share, then they are joinable. */
  @tailrec
  def join(eid0: EntityId, eid1: EntityId): Option[EntityId] = (eid0, eid1) match {
    case (a: CompoundId, b: CompoundId) =>
      val (smaller, larger) = if (a.ids.size < b.ids.size) (a.ids, b.ids) else (b.ids, a.ids)
      if (smaller != a.ids.intersect(b.ids)) None else larger.size match {
        case 0 => Some(UnitId())
        case 1 => larger.headOption
        case _ => Some(CompoundId(larger))
      }
    case (a, b) => join(CompoundId(a), CompoundId(b))
  }
}

object CompoundId {

  /** Construct a CompoundId from other types of EntityIds. */
  def apply(eid: EntityId): CompoundId = eid match {
    case x: CompoundId => x
    case _: UnitId => CompoundId(Set.empty[EntityId])
    case x => CompoundId(Set(x))
  }
}

/**
  * A `Datum` (singular) is a (single) datapoint corresponding to some entity at some point in time.  The
  * data type is determined by the collection or stream that holds the data set to which the datum belongs.
  *
  * @param id          Entity ID to which this datum belongs
  * @param sourceTime  Source/event/producer time when datum was generated by its source
  * @param knownTime   Ingestion/processing/consumer time when datum became known to the receiving system
  *                    http://blog.colinbreck.com/considering-time-in-a-streaming-data-system/
  * @param value       The value of this datapoint
  */
case class Datum[T](id: EntityId, sourceTime: TimeStamp, knownTime: TimeStamp, value: T)


object Datum {

  /** Shortcut if the two timestamps are the same. */
  def apply[T](id: EntityId, ts: TimeStamp, value: T): Datum[T] = Datum(id, ts, ts, value)
}